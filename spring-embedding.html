<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>自動描画されるグラフ</title>
    <script>
      const SVG_NS = "http://www.w3.org/2000/svg";

      let svg, svgPoint, plusButton;
      let focusedNode = null;
      // type NodeId = int
      // type Node = { id: NodeId, weight: int, velocity: Velocity, x: number, y: number }
      // type Velocity = { x: number, y: number }
      // nodes :: Array<NodeId, Node>
      const nodes = [
        { id: 0, weight: 1, velocity: { x: 0, y: 0 }, x: 150, y: 100 }
      ];
      // graph :: Array<NodeId, Array<NodeId, number>>
      // 最初のノードは一つだけなので距離は0だけ。
      const graph = [
        [0]
      ];

      const distance = (node1, node2) => {
        return Math.sqrt(Math.pow(node1.x - node2.x, 2) + Math.pow(node1.y - node2.y, 2));
      };

      const adjustNodePositions = () => {
          // const g  = 0.01; // 原点への引力
          const q  = 0.2; // ノード間の斥力
          const k  = 1.0; // ばね定数
          const l  = 1.0; // ばねの自然長
          const mu = 0.9; // 摩擦係数
          const dt = 0.1; // 微小時間
          const e  = 0.1; // 運動エネルギーのしきい値

          let kineticEnergy = 0;
          // 速度の初期化。再配置の度に一度0にする
          for (const node of nodes) {
            node.velocity = { x: 0, y: 0 };
          }

          do {
            for (const node1 of nodes) {
              let power = { x: 0, y: 0 };
              for (const node2 of nodes) {
                if (node1.id === node2.id) { continue; }
                let d = distance(node1, node2);
                // クーロン力
                power.x = power.x + q / Math.pow(d, 2);
                power.y = power.y + q / Math.pow(d, 2);
              }

              for (const node2Id of graph[node1.id].keys()) {
                if (node1.id === node2Id) { continue; }
                const node2 = nodes[node2Id];
                let d = distance(node1, node2);
                // フックの法則による力
                power.x = power.x + k * (d - l);
                power.y = power.y + k * (d - l);
              }

              node1.velocity.x = (node1.velocity.x + dt * power.x / node1.weight) * mu;
              node1.velocity.y = (node1.velocity.y + dt * power.y / node1.weight) * mu;
              node1.x = node1.x + dt * node1.velocity.x;
              node1.y = node1.y + dt * node1.velocity.y;

              const node1Velocity = Math.pow(node1.velocity.x, 2) + Math.pow(node1.velocity.y, 2);
              kineticEnergy = kineticEnergy + node1.weight * node1Velocity;
            }
          } while (kineticEnergy > e);
      };

      const getCursorPosition = (event) => {
        svgPoint.x = event.clientX;
        svgPoint.y = event.clientY;
        return svgPoint.matrixTransform(svg.getScreenCTM().inverse());
      }

      const createNodeBy = (adjacent, cursorPosition) => {
        const newNode = {
          id: nodes.length,
          weight: 1,
          velocity: { x: 0, y: 0 },
          x: cursorPosition.x,
          y: cursorPosition.y
        };
        nodes.push(newNode);
        // TODO: 多分ここで設定したdistanceは使わなくていいので最適化
        graph[adjacent.id][newNode.id] = distance(adjacent, newNode);
        graph[newNode.id] = [];
        graph[newNode.id][newNode.id] = 0;
        return newNode;
      };

      const radius = 20;
      const plusButtonDiameter = 20;
      const outerRadius = radius * 1.5;
      const circleCenter = plusButtonDiameter + outerRadius;

      const drawNewNode = (node) => {
        const thickness = 2;

        const nodeSvg = document.createElementNS(SVG_NS, 'svg');
        nodeSvg.setAttribute('x', node.x - circleCenter);
        nodeSvg.setAttribute('y', node.y - circleCenter);
        nodeSvg.setAttribute('width',  circleCenter * 2);
        nodeSvg.setAttribute('height', circleCenter * 2);
        nodeSvg.setAttribute('id', `node-${node.id}`);

        const circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('cx', circleCenter);
        circle.setAttribute('cy', circleCenter);
        circle.setAttribute('r', radius);
        circle.setAttribute('fill-opacity', 0);
        circle.setAttribute('stroke', 'black');
        circle.setAttribute('stroke-width', thickness);
        nodeSvg.appendChild(circle);

        const outer = document.createElementNS(SVG_NS, 'circle');
        outer.setAttribute('cx', circleCenter);
        outer.setAttribute('cy', circleCenter);
        outer.setAttribute('r', outerRadius);
        outer.setAttribute('fill', 'none');
        outer.setAttribute('pointer-events', 'stroke');
        outer.setAttribute('stroke-width', plusButtonDiameter);
        outer.addEventListener('mousemove', event => {
          focusedNode = node;
          const cursorPosition = getCursorPosition(event);
          plusButton.setAttribute('x', cursorPosition.x - plusButtonDiameter);
          plusButton.setAttribute('y', cursorPosition.y - plusButtonDiameter);
          plusButton.setAttribute('visibility', 'visible');
        });
        outer.addEventListener('mouseleave', () => {
          plusButton.setAttribute('visibility', 'hidden');
          focusedNode = null;
        });
        outer.addEventListener('click', (event) => {
          if (focusedNode === null) { return; }
          const cursorPosition = getCursorPosition(event);
          const newNode = createNodeBy(focusedNode, cursorPosition);
          drawNewNode(newNode);
          adjustNodePositions();
          redraw();
        });
        nodeSvg.appendChild(outer);

        const label = document.createElementNS(SVG_NS, 'text');
        label.setAttribute('x', circleCenter * 0.89);
        label.setAttribute('y', circleCenter * 1.15);
        label.setAttribute('font-size', 20);
        label.appendChild(document.createTextNode(node.weight.toString()));

        nodeSvg.appendChild(label);
        svg.insertBefore(nodeSvg, plusButton);
      };
      const redraw = () => {
        for (const node of nodes) {
          moveNode(node);
        }
      };
      const moveNode = (node) => {
        const nodeSvg = document.getElementById(`node-${node.id}`);
        nodeSvg.setAttribute('x', node.x - circleCenter);
        nodeSvg.setAttribute('y', node.y - circleCenter);
      };
      const init = () => {
        svg = document.getElementById('graph');
        svgPoint = svg.createSVGPoint();
        plusButton = document.getElementById('plus-button');
        drawNewNode(nodes[0]);
      }
    </script>
  </head>
  <body onload="init()">
    <h1>自動描画されるグラフ</h1>
    <svg id="graph" width="2000" height="2000" xmlns="http://www.w3.org/2000/svg">
      <svg stroke="#000" visibility="hidden" id="plus-button">
        <circle r="10" cx="25" cy="25" fill="none" stroke-width="2"/>
        <rect transform="translate(-5, 0)" x="25" y="25" width="10" height=".5" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/>
        <rect transform="translate(0, -5)" x="25" y="25" width=".5" height="10" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/>
      </svg>
    </svg>
  </body>
</html>
